// Copyright 2022 Terin Stock.
// SPDX-License-Identifier: MPL-2.0

// Package stol implements the "short token, okay length" IDs.
package stol

import (
	"io"
)

/*
STOL is a 4-byte identifier that can be roughly sorted to day specificity.

		0                   1
		0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
		+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		| 16_bit_unit_day_counter       |
		+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        | 16_bit_uint_random            |
		+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*/
// STOL is a roughly sortable ID.
type STOL [4]byte

// New returns a STOL with the given day count and entropy source.
//
// Safety for concurrent use is dependent on the safety of the
// entropy source.
func New(dc uint16, r io.Reader) (STOL, error) {
	id := STOL{}
	id[0] = byte(dc >> 8)
	id[1] = byte(dc)

	_, err := io.ReadFull(r, id[2:])

	return id, err
}

// Parse parses an encoded STOL.
func Parse(s string) (STOL, error) {
	id := &STOL{}
	p := []byte(s)

	(*id)[0] = (dec[p[0]] << 7) | (dec[p[1]] << 2) | (dec[p[2]] >> 3)
	(*id)[1] = (dec[p[2]] << 5) | dec[p[3]]

	(*id)[2] = (dec[p[4]] << 7) | (dec[p[5]] << 2) | (dec[p[6]] >> 3)
	(*id)[3] = (dec[p[6]] << 5) | dec[p[7]]

	return *id, nil
}

// Days returns the day counter encoded in the STOL.
func (id STOL) Days() uint16 {
	return uint16(id[0])<<8 | uint16(id[1])
}

// Entropy returns the entropy from the STOL.
func (id STOL) Entropy() []byte {
	p := make([]byte, 2)
	copy(p, id[2:])
	return p
}

// String returns a roughly sortable string encoded STOL.
// (8 characters, non-standard base 32).
// Format: ddddeeee where d is the day count and e is entropy.
func (id STOL) String() string {
	stol := make([]byte, EncodedSize)
	_ = id.MarshalTextTo(stol)
	return string(stol)
}

const EncodedSize = 8

// Encoding is the base 32 encoding alphabet used in STOL strings.
const Encoding = "0123456789ABCDEFGHJKMNPQRSTVWXYZ"

// Byte to index table for O(1) lookups when unmarshaling.
// We use 0xFF as sentinel value for invalid indexes.
var dec = [...]byte{
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x01,
	0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
	0x0F, 0x10, 0x11, 0xFF, 0x12, 0x13, 0xFF, 0x14, 0x15, 0xFF,
	0x16, 0x17, 0x18, 0x19, 0x1A, 0xFF, 0x1B, 0x1C, 0x1D, 0x1E,
	0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C,
	0x0D, 0x0E, 0x0F, 0x10, 0x11, 0xFF, 0x12, 0x13, 0xFF, 0x14,
	0x15, 0xFF, 0x16, 0x17, 0x18, 0x19, 0x1A, 0xFF, 0x1B, 0x1C,
	0x1D, 0x1E, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
}

// MarshalTextTo writes the STOL as a string into the given buffer.
func (id STOL) MarshalTextTo(dst []byte) error {
	// Encode Day Counter:
	//   dst[0]: first 1 bits of data[0]
	//   dst[1]: bits 2-6 of data[0]
	//   dst[2]: last 2 bits of data[0] + first 3 bits of data[1]
	//   dst[3]: last 5 bits of data[1]
	dst[0] = Encoding[(id[0]&128)>>7]
	dst[1] = Encoding[(id[0]&124)>>2]
	dst[2] = Encoding[((id[0]&3)<<3)|((id[1]&224)>>5)]
	dst[3] = Encoding[id[1]&31]

	// Encode Random:
	//   dst[4]: first 1 bits of data[2]
	//   dst[5]: bits 2-6 of data[2]
	//   dst[6]: last 2 bits of data[2] + first 3 bits of data[3]
	//   dst[7]: last 5 bits of data[3]
	dst[4] = Encoding[(id[2]&128)>>7]
	dst[5] = Encoding[(id[2]&124)>>2]
	dst[6] = Encoding[((id[2]&3)<<3)|((id[3]&224)>>5)]
	dst[7] = Encoding[id[3]&31]

	return nil
}
